"""This module provides the expandvars() function."""

import string
import logging

log = logging.getLogger("torizon." + __name__)

VAR_FIRST_CHAR = string.ascii_letters + "_"
VAR_SECND_CHAR = string.ascii_letters + "_" + string.digits

class UserFailureException(Exception):
    """Exception generated by the ${VAR?...} notation"""


# pylint: disable=too-many-branches,too-many-statements
def expand(source, environ=None):
    """Expand shell-like expressions of the form $VAR and similar

    The following notations are currently supported:

    - $VAR, ${VAR}: basic substitution notations that will expand to the value
                    of variable VAR.
    - ${VAR:?message}: Raise exception with 'message' when VAR is empty or not
                       set.
    - ${VAR?message}: Raise exception with 'message' when VAR is not set.
    - ${VAR:-default}: Expand as 'default' when VAR is empty or not set.
    - ${VAR-default}: Expand as 'default' when VAR is not set.

    :param source: String possibly containing the shell-like expressions.
    :param environ: Dictionary providing the values assigned to the variables.
    """

    if environ is None:
        environ = {}

    def process(ini_pos, level):
        cur_pos = ini_pos
        output = []
        while True:
            close_pos = -1
            sign_pos = source.find("$", cur_pos)
            if level > 0:
                close_pos = source.find("}", cur_pos)

            if close_pos != -1 and sign_pos != -1:
                # See which came before: closing brace or dollar sign.
                if close_pos < sign_pos:
                    output.append(source[cur_pos:close_pos])
                    cur_pos = close_pos
                    break
            elif close_pos != -1 and sign_pos == -1:
                output.append(source[cur_pos:close_pos])
                cur_pos = close_pos
                break
            elif close_pos == -1 and sign_pos == -1:
                output.append(source[cur_pos:])
                cur_pos = len(source)
                break

            # Consume characters before the dollar sign.
            output.append(source[cur_pos:sign_pos])
            cur_pos = sign_pos + 1
            # Handle following character.
            cur_ch = source[cur_pos : cur_pos + 1]
            next_ch = source[cur_pos + 1 : cur_pos + 2]
            if cur_ch == "$":
                # Handle $$.
                output.append("$")
                cur_pos += 1
            elif cur_ch in VAR_FIRST_CHAR:
                # Handle variable specified as $VAR.
                value, cur_pos = get_var1(cur_pos)
                output.append(value)
            elif cur_ch == "{" and next_ch in VAR_FIRST_CHAR:
                # Handle variable specified as ${VAR}.
                value, cur_pos = get_var2(cur_pos, level)
                output.append(value)
            else:
                output.append("$")

        return "".join(output), cur_pos

    def get_var1(pos):
        var_name = []
        while pos < len(source):
            if source[pos] not in VAR_SECND_CHAR:
                break
            var_name.append(source[pos])
            pos += 1
        # Build variable name.
        var_name = "".join(var_name)
        var_value = ""
        if var_name in environ:
            var_value = environ[var_name]
            log.debug(f"Variable expansion: {var_name} -> '{var_value}'")
        else:
            log.warning(f"Variable {var_name} is not set: assuming an empty string")

        return var_value, pos

    def get_var2(pos, level):
        assert source[pos] == "{"
        ini_pos = pos
        pos += 1
        var_name = []
        while pos < len(source):
            if source[pos] not in VAR_SECND_CHAR:
                break
            var_name.append(source[pos])
            pos += 1

        # Build variable name.
        var_name = "".join(var_name)
        var_value = ""
        var_except = None
        if source[pos:pos+2] == ":-":
            # Handle the ${VAR:-default} notation.
            inner_value, pos = process(pos + 2, level + 1)
            if (var_name not in environ) or (environ[var_name] == ""):
                var_value = inner_value
            else:
                var_value = environ[var_name]

        elif source[pos:pos+1] == "-":
            # Handle the ${VAR-default} notation.
            inner_value, pos = process(pos + 1, level + 1)
            if var_name not in environ:
                var_value = inner_value
            else:
                var_value = environ[var_name]

        elif source[pos:pos+2] == ":?":
            # Handle the ${VAR?-error} notation.
            inner_value, pos = process(pos + 2, level + 1)
            if (var_name not in environ) or (environ[var_name] == ""):
                var_except = UserFailureException(f"{inner_value}")
            else:
                var_value = environ[var_name]

        elif source[pos:pos+1] == "?":
            # Handle the ${VAR?error} notation.
            inner_value, pos = process(pos + 1, level + 1)
            if var_name not in environ:
                var_except = UserFailureException(f"{inner_value}")
            else:
                var_value = environ[var_name]

        elif source[pos:pos+1] == "}":
            # Handle the ${VAR} basic notation.
            if var_name in environ:
                var_value = environ[var_name]
                log.debug(f"Variable expansion: {var_name} -> '{var_value}'")
            else:
                log.warning(f"Variable {var_name} is not set: assuming an empty string")

        else:
            raise Exception("Unknown variable expansion syntax near "
                            f"'{source[ini_pos:ini_pos+10]}'")

        if source[pos:pos+1] != "}":
            raise Exception("Unclosed brace in variable expansion near "
                            f"'{source[ini_pos:ini_pos+10]}'")

        if var_except is not None:
            raise var_except

        pos += 1
        log.debug(f"Variable expansion: {var_name} -> '{var_value}'")

        return var_value, pos

    return process(0, 0)[0]
# pylint: enable=too-many-branches,too-many-statements


# Use pytest to unit test this module (TODO).
#if __name__ == '__main__':
#    def check_expansion(source, environ, expected=None):
#        try:
#            actual = expand(source, environ)
#        except Exception as exc:
#            if expected is None:
#                print(f" [OK] Expansion of '{source}' failed as expected")
#            else:
#                print(f"[NOK] Expansion of '{source}' issued an exception '{str(exc)}'")
#            return
#
#        if actual == expected:
#            print(f" [OK] Expansion of '{source}' is correct")
#        else:
#            print(f"[NOK] Expansion of '{source}' is wrong ('{actual}' != '{expected}')")
#
#    check_expansion(r"//$VAR1##", {'VAR1_': ''}, r"//##")
#    check_expansion(r"##$VAR1//", {'VAR1': ''}, r"##//")
#    check_expansion(r"//$VAR1//", {'VAR1': 'var1_value'}, r"//var1_value//")
#
#    check_expansion(r"//${VAR1}##", {'VAR1_': ''}, r"//##")
#    check_expansion(r"##${VAR1}//", {'VAR1': ''}, r"##//")
#    check_expansion(r"//${VAR1}//", {'VAR1': 'var1_value'}, r"//var1_value//")
#
#    check_expansion(r"//${VAR1:-var1_default}//", {'VAR1_': ''}, r"//var1_default//")
#    check_expansion(r"//${VAR1:-var1_default}//", {'VAR1': ''}, r"//var1_default//")
#    check_expansion(r"//${VAR1:-var1_default}//", {'VAR1': 'var1_value'}, r"//var1_value//")
#
#    check_expansion(r"//${VAR1-var1_default}##", {'VAR1_': ''}, r"//var1_default##")
#    check_expansion(r"##${VAR1-var1_default}//", {'VAR1': ''}, r"##//")
#    check_expansion(r"//${VAR1-var1_default}//", {'VAR1': 'var1_value'}, r"//var1_value//")
#
#    check_expansion(r"//${VAR1:?VAR1 must be set!!}//", {'VAR1_': ''}, None)
#    check_expansion(r"//${VAR1:?VAR1 must be set and not empty}//", {'VAR1': ''}, None)
#    check_expansion(
#        r"//${VAR1:?VAR1 must be set and not empty}//", {'VAR1': 'var1_value'},
#        r"//var1_value//")
#
#    check_expansion(r"//${VAR1?VAR1 must be set!!}//", {'VAR1_': ''}, None)
#    check_expansion(r"//${VAR1?VAR1 must be set and not empty}//", {'VAR1': ''}, r"////")
#    check_expansion(
#        r"//${VAR1?VAR1 must be set and not empty}//", {'VAR1': 'var1_value'},
#        r"//var1_value//")
#
#    check_expansion(
#        r"${VAR1-var1_default}//${VAR2-var2_default}//"
#        r"${VAR3-this is $DEFVALUE of var3}",
#        {'VAR1': 'var1_value', 'VAR2': 'var2_value', 'DEFVALUE': 'def_var3'},
#        r"var1_value//var2_value//this is def_var3 of var3")
#
#    check_expansion(
#        r"${VAR1-var1_default}$$${VAR2-var2_default}//"
#        r"${VAR3-this_is_${DEFVALUE}_of_var3}",
#        {'VAR1': 'var1_value', 'VAR2': 'var2_value', 'DEFVALUE': 'def_var3'},
#        r"var1_value$var2_value//this_is_def_var3_of_var3")
#
#    check_expansion(
#        r"${VAR1-var1_default}//${VAR2-var2_default}//"
#        r"${VAR3-this is ${DEFVALUE} of var3}",
#        {'VAR1': 'var1_value', 'VAR2': 'var2_value', 'DEFVALUE': 'def_var3'},
#        r"var1_value//var2_value//this is def_var3 of var3")
#
#    check_expansion(
#        r"${VAR1-var1_default}//${VAR2-var2_default}//"
#        r"${VAR3-this is ${UNKNOWN-use_${DEFVALUE}_if_unknown} of var3}.",
#        {'VAR1': 'var1_value', 'VAR2': 'var2_value', 'DEFVALUE': '*VAR3*'},
#        r"var1_value//var2_value//this is use_*VAR3*_if_unknown of var3.")
#
#    check_expansion(
#        r"${VAR1-var1_default}//${VAR2-var2_default}//"
#        r"${VAR3-this is ${UNKNOWN-use_${DEFVALUE}_if_unknown} of var3}.",
#        {'VAR1': 'var1_value', 'VAR2': 'var2_value', 'VAR3': 'var3_value'},
#        r"var1_value//var2_value//var3_value.")
#
#    check_expansion(
#        r"${VAR1-1${VAR2-2${VAR3-3${VAR4}3}2}1}--${VAR1-1${VAR2-2${VAR3b-3${VAR4}3}2}1}",
#        {'VAR4': 'var4_value', 'VAR3b': 'var3_value'},
#        r"123var4_value321--12var3_value21")
#
#    check_expansion(
#        r"${VAR1:-${VAR2-${VAR3-${VAR4}}}}",
#        {'VAR1': 'var1_value', 'VAR2': 'var2_value'},
#        r"var1_value")
#    check_expansion(
#        r"${VAR1:-${VAR2-${VAR3-${VAR4}}}}",
#        {'VAR1': '', 'VAR2': 'var2_value'},
#        r"var2_value")
#    check_expansion(
#        r"${VAR1:-${VAR2:-${VAR3:-${VAR4}}}}",
#        {'VAR1': '', 'VAR2': '', 'VAR3': 'var3_value'},
#        r"var3_value")
